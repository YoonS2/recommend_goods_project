%LET BIZ=A1;
%LET ST='20210416';
%LET END='20210430' ; /*예측데이터 시기. 신상품 제외위함*/
%LET ST1 ='16MAY2021'D;
%LET END1 ='31MAY2021'D ;/*판매율로 제외상품거르기 */
%LET TEST_RAW=  SUSER40.AMT_LINE39_A1_예측20210416;  /*예측데이터 AMT */
%LET LIST = TEST2.REPORT_LIST_2021_1ST ;
%let LINE = 39;
%LET NUM1=20210401; /*학습num*/
%LET NUM2=20210416; /*예측 num*/
PROC SORT DATA=TEST2.TS_MS_BIZPL OUT=공결점포01 ; BY ORIGIN_BIZPL_CD  DESCENDING OPEN_DT; RUN;
PROC SORT DATA=공결점포01 OUT=공결점포02 DUPOUT=공결점포03 NODUPKEY; BY ORIGIN_BIZPL_CD; RUN;

PROC SQL;
CREATE TABLE GOOD_DM AS 
SELECT BD_ITEM_LCLS_CD AS 대분류코드
          ,BD_ITEM_LCLS_NM AS 대분류명
          ,BD_ITEM_MCLS_CD AS LINE_CD
          ,BD_ITEM_MCLS_NM AS LINE_NM
          ,BD_ITEM_SCLS_CD AS CLASS_CD
		  ,BD_ITEM_SCLS_NM AS CLASS_NM
		  ,BD_ITEM_DCLS_CD AS 세분류코드
		  ,BD_ITEM_DCLS_NM AS 세분류명
          ,COMPRESS(BD_ITEM_CD) AS GOODS_CD
          ,COMPRESS(BD_ITEM_NM) AS GOODS_NM
  FROM GSSELDW.TB_DM_BD_ITEM_BASE
  WHERE BIZU_CD='1' /*편의점코드*/
;
QUIT;
/*학습*/

OPTION nonotes nosource nomlogic nomprint NOSOURCE2 ;

PROC SQL; 
CREATE TABLE DEL_&BIZ. AS
SELECT BF_ORIGIN ,SUM(TA) AS TASUM ,COUNT(*) AS N
FROM SUSER40.TRAIN_&BIZ._80
/*_&NUM1.*/
GROUP BY 1
HAVING TASUM=0 OR (TASUM=N)

;
QUIT; 


PROC SQL; 
CREATE TABLE TRAIN_&BIZ. AS
SELECT A.*
FROM SUSER40.TRAIN_&BIZ._80 AS A
/*_&NUM1. AS A*/
WHERE BF_ORIGIN NOT IN (SELECT BF_ORIGIN FROM DEL_&BIZ.) /*TA가 모두 0이거나 1인 점포제외*/
ORDER BY BF_ORIGIN;
QUIT; 

/*--------------------------------------------------------로지스틱*/
PROC LOGISTIC DATA=TRAIN_&BIZ.  NOPRINT;
BY BF_ORIGIN ;
MODEL TA(event='1')=PRE_TFIDF PRE_QTY; 
OUTPUT OUT=TEST01_&BIZ. P=PRED;
STORE STACKING_LOGISTIC;
RUN;


PROC SQL;
CREATE TABLE TEST_02_&BIZ. AS
SELECT A.*
			,A.BF_ORIGIN 
			,F.DIST_ORGANIZE_SP
			,D.CLASS_CD
			,D.CLASS_NM
			,D.세분류코드
			,D.세분류명
FROM SUSER40.TEST_SET_&BIZ._&NUM2.  AS A
LEFT JOIN TEST2.TS_MS_GOODS AS F ON A.GOODS_CD = F.GOODS_CD
LEFT JOIN GOOD_DM AS D ON A.GOODS_CD = D.GOODS_CD
WHERE BF_ORIGIN IN (SELECT BF_ORIGIN FROM  TRAIN_&BIZ.)
;
QUIT;


PROC SORT DATA= TEST_02_&BIZ. OUT=TEST_021_&BIZ.; BY BF_ORIGIN ;RUN;
PROC PLM SOURCE=STACKING_LOGISTIC NOPRINT;
SCORE DATA=TEST_021_&BIZ. OUT=TEST_022_&BIZ. PREDICTED=PRED / ILINK;

DATA TEST_SCORE01_&BIZ.;
SET TEST_022_&BIZ.;
IF PRED>0.5 THEN SURVIVED = 1;ELSE SURVIVED=0;
RUN;


/*우수 상품*/

PROC SORT DATA=TEST_SCORE01_&BIZ. OUT=TEST_SCORE011_&BIZ.;
BY BF_ORIGIN LINE_CD;
RUN;

PROC MEANS DATA=TEST_SCORE011_&BIZ. MEAN Q3 Q1 NOPRINT;
WHERE REAL_QTY^=.;
BY BF_ORIGIN LINE_CD;
VAR PRE_QTY;
OUTPUT OUT=TA_IDF_SIX
Q3 = SIX_Q3
Q1 = SIX_Q1
MEAN = SIX_MEAN;
RUN;


PROC SQL;
CREATE TABLE TEST_BEST_&BIZ. AS
SELECT A.*
			,CASE WHEN A.PRE_QTY>B.SIX_Q3 THEN 1 ELSE 0 END AS DEL
			,SIX_Q3
FROM TEST_SCORE01_&BIZ. AS A
LEFT JOIN TA_IDF_SIX AS B ON A.LINE_CD = B.LINE_CD AND A.BF_ORIGIN = B.BF_ORIGIN
LEFT JOIN GOOD_DM AS C ON A.GOODS_CD = C.GOODS_CD
WHERE REAL_TFIDF^=.
HAVING DEL=1 AND SURVIVED=1
ORDER BY BF_ORIGIN, LINE_CD, PRE_QTY DESC
;
QUIT;

	/*예측데이터기간  재고테이블 */
	PROC SQL;
	CREATE TABLE STK&LINE._BEFORERAW&NUM2.  AS
	SELECT
				COMPRESS("V"||A.STORECD) AS BF_ORIGIN 
				,B.GOODS_CD
				,DATECD
				,BUY_QTY
				,STK_QTY 
				,SAL_QTYGSSELDW
	FROM TEST2.TB_STK_FT AS A
	INNER JOIN TEST_02_&BIZ. AS B
  ON A.GOODCD=B.GOODS_CD AND  COMPRESS("V"||A.STORECD) =B.BF_ORIGIN 
	WHERE DATECD BETWEEN &ST1.	AND &END1.
AND (BUY_QTY>0 OR STK_QTY>0 OR SAL_QTY>0)
AND GOODCD IN (SELECT GOODS_CD FROM TEST_02_&BIZ. ) 
	;
QUIT; 
DATA SUSER40.STK&LINE._BEFORERAW&NUM2.  ;
SET STK&LINE._BEFORERAW&NUM2. ;
RUN;

/*유형별 취급율 10%이하 상품 제외. 극단적으로 낮은 상품*/
/*취급: 입고판매가 있는 상품으로 정의*/

DATA STK&LINE._BEFORERAW   ;
SET SUSER40.STK&LINE._BEFORERAW   ;
RUN;
PROC SQL ;
CREATE TABLE BIZPL_N AS
SELECT B.BIZPL_CL_DIV_CD,COUNT(DISTINCT A.ORIGIN_BIZPL_CD) AS 운영점포수 
FROM GSSELDW.TB_FT_CVS_TR_HDR AS A
INNER JOIN &LIST. AS B
ON A.ORIGIN_BIZPL_CD=B.ORIGIN_BIZPL_CD
WHERE A.OPER_DT BETWEEN &ST. AND &END.
GROUP BY 1
;
QUIT; 
PROC SQL;
CREATE TABLE &BIZ._SKT AS
SELECT GOODS_CD,N,운영점포수,N/운영점포수 AS 취급율 
FROM (SELECT GOODS_CD,COUNT(DISTINCT BF_ORIGIN) AS N 
		FROM  STK&LINE._BEFORERAW
		WHERE BUY_QTY>0 OR SAL_QTY>0 
		GROUP BY 1) AS A
LEFT JOIN BIZPL_N AS B
ON 1=1
WHERE  B.BIZPL_CL_DIV_CD ='A1'

;
QUIT; 

/*추천시기 신상품 제외*/
PROC SORT DATA=TEST2.TS_MS_GOODS OUT=DETAIL;
BY GOODS_CD DESCENDING CLS_APPDT;
RUN;


PROC SORT DATA=DETAIL OUT=DETAIL01 DUPOUT=DETAIL02 NODUPKEY;
BY GOODS_CD;RUN;


/*TM단품 정리*/
PROC SQL;
CREATE TABLE TM AS
SELECT B.대분류코드
               ,B.대분류명
               ,B.LINE_CD
                ,B.LINE_NM
                ,B.CLASS_cD
                ,B.CLASS_NM
                ,A.GOODS_CD
                ,B.GOODS_NM
				,TARGET_MARKET_SP
FROM TEST2.TS_MG_GOODS AS A
LEFT JOIN GOOD_DM AS B ON A.GOODS_CD=B.GOODS_CD
WHERE TARGET_MARKET_SP^='' /*TM단품가져오기*/
;
QUIT;

/*---------------------대체상품 추천*/
%LET 기준=세분류명;  /*우유의 경우 특정 세분류에 쏠리지 않고 구색용 필요, 세분류 기준으로 추천함. FF는 소분류*/

PROC SQL;
CREATE TABLE TEST_SCORE02_&BIZ. AS
SELECT A.*,B.GOODS_REGION_CD AS BIZPL_REGION_CD,C.GOODS_REGION_CD ,D.취급율 
FROM TEST_SCORE01_&BIZ. AS A
LEFT JOIN 공결점포02 AS B
ON A.BF_ORIGIN=B.ORIGIN_BIZPL_CD
INNER JOIN TEST2.TS_MG_GOODS_DETAIL AS C
ON A.GOODS_CD=C.GOODS_CD AND B.GOODS_REGION_CD=C.GOODS_REGION_CD
LEFT JOIN  &BIZ._SKT AS D
ON A.GOODS_CD=D.GOODS_CD 
WHERE A.GOODS_CD NOT IN (SELECT DISTINCT GOODS_CD
											FROM DETAIL01 
											WHERE CLS_APPDT BETWEEN &ST.  AND &END.) /*신상제외*/
HAVING 취급율 >=0.1

ORDER BY BF_ORIGIN,&기준. , PRE_QTY DESC
;
QUIT;
PROC SQL; 
CREATE TABLE TEST_SCORE03_&BIZ. AS
SELECT A.*
FROM TEST_SCORE02_&BIZ. AS A
WHERE SURVIVED=1 AND REAL_QTY=. 
AND GOODS_CD NOT IN (SELECT GOODS_CD FROM TM) 
;
QUIT; 
PROC SORT DATA=TEST_SCORE03_&BIZ. ;BY BF_ORIGIN &기준. DESCENDING PRE_QTY ;QUIT; 

/*수익 고려위한 테이블 */
PROC SORT DATA=TEST2.TS_MG_GOODS_DETAIL OUT=PRC_TEST;
BY GOODS_CD GOODS_REGION_CD DESCENDING INSERT_DTTM;RUN;
PROC SORT DATA=PRC_TEST OUT=PRC_TEST01 DUPOUT=A NODUPKEY;
BY GOODS_CD GOODS_REGION_CD;RUN;
PROC SQL; 
CREATE TABLE TEST_SCORE04_&BIZ. AS
SELECT A.*,B.PRC,B.COST, (B.PRC-B.COST)*A.PRE_QTY AS PRE_PROFIT  
FROM TEST_SCORE03_&BIZ. AS A
LEFT JOIN PRC_TEST01 AS B
ON A.GOODS_CD=B.GOODS_CD AND A.GOODS_REGION_CD=B.GOODS_REGION_CD
ORDER BY BF_ORIGIN, &기준. ,PRE_QTY DESC 
;
QUIT; 
DATA TEST_SCORE04_&BIZ.;
SET  TEST_SCORE04_&BIZ.;
BY BF_ORIGIN &기준. ;
RANK +1 - RANK*FIRST.&기준. ;
RUN;


/*제외상품 목록, PRE_QTY낮은순*/
PROC SQL; 
CREATE TABLE DEL_GOODS_&BIZ. AS
SELECT A.*,B.GOODS_REGION_CD AS BIZPL_REGION_CD, 
D.PRC,D.COST, (D.PRC-D.COST)*A.PRE_QTY AS PRE_PROFIT  
FROM TEST_02_&BIZ. AS A
LEFT JOIN 공결점포02 AS B
ON A.BF_ORIGIN=B.ORIGIN_BIZPL_CD
LEFT JOIN PRC_TEST01 AS D
ON A.GOODS_CD=D.GOODS_CD AND B.GOODS_REGION_CD=D.GOODS_REGION_CD
WHERE REAL_QTY ^=. 
ORDER BY BF_ORIGIN, &기준. ,REAL_QTY,PRE_PROFIT
;
QUIT; 
DATA DEL_GOODS_&BIZ. ;
SET DEL_GOODS_&BIZ. ;
BY BF_ORIGIN &기준. ;
RANK+1-RANK*FIRST.&기준. ;
RUN;



PROC SQL;
CREATE TABLE TEST_REC_&BIZ. AS
SELECT A.*
			,B.GOODS_CD AS GOODS_CD_YN
			,B.GOODs_NM AS GOODS_NM_YN
			,B.PRE_QTY AS PRE_YN
			,B.REAL_QTY AS REAL_YN
			,B.PRE_PROFIT AS PROFIT_YN
			,CASE WHEN B.PRE_QTY-A.PRE_QTY >0.07 THEN 0 ELSE 1 END AS DEL1
			,CASE WHEN B.PRE_QTY-A.REAL_QTY >0.07 THEN 0 ELSE 1 END AS DEL2
			,CASE WHEN B.PRE_PROFIT-A.PRE_PROFIT >0 THEN  0 ELSE 1 END AS DEL3  /*수익 고려*/
FROM DEL_GOODS_&BIZ. AS A
INNER JOIN  TEST_SCORE04_&BIZ. AS B 
ON A.BF_ORIGIN = B.BF_ORIGIN AND A.&기준.=B.&기준. AND A.RANK=B.RANK
HAVING DEL1=0 AND DEL2=0
/*14일동안 1개라도 더 팔리게! 0.07개 이상 차이 나는것  */
ORDER BY A.BF_ORIGIN ,A.CLASS_NM, A.&기준. ,A.RANK ;
;
QUIT;
DATA SUSER40.TEST_REC_&BIZ.;
SET TEST_REC_&BIZ. ;
RUN;
/*빛매니저님 추천상품 목록 공유용 */
PROC SQL; 
CREATE TABLE ZTC_LIB.GOODS_LIST_TEST AS
(SELECT BF_ORIGIN AS ORIGIN_BIZPL_CD
,BF_BIZ AS BIZPL_NM
,LINE_CD
,LINE_NM
,CLASS_CD
,CLASS_NM
,GOODS_CD_YN AS GOODS_CD
,GOODS_NM_YN AS GOODS_NM
,PRE_YN AS PRE_QTY 
,REAL_YN AS REAL_QTY

FROM TEST_REC_&BIZ. )/* 미취급*/
UNION ALL
(SELECT BF_ORIGIN AS ORIGIN_BIZPL_CD
,BF_BIZ AS BIZPL_NM
,LINE_CD
,LINE_NM
,CLASS_CD
,CLASS_NM
,GOODS_CD
,GOODS_NM
,PRE_QTY
,REAL_QTY
FROM TEST_BEST_&BIZ. /* 우수*/
)
ORDER BY ORIGIN_BIZPL_CD, PRE_QTY DESC 
;
QUIT; 



/*추천목록 수정*/
/*점별 기준 카테고리의 추천대상 상품수파악*/
PROC SQL; 
CREATE TABLE  REC_MAX AS
SELECT BF_ORIGIN,BF_BIZ,&기준.,COUNT(*)  AS N,MAX(PRE_QTY) AS MAX_PREQTY
		FROM TEST_SCORE04_&BIZ. 
			GROUP BY 1,2,3

;
QUIT; 

PROC SQL NOPRINT ;
SELECT MAX(N) INTO : TOTAL_MAXN FROM REC_MAX ;
QUIT;
%PUT &TOTAL_MAXN;

PROC SQL; 
CREATE TABLE DEL_LIST2_&BIZ. AS
SELECT A.*
FROM DEL_GOODS_&BIZ. AS A 
LEFT JOIN REC_MAX AS B
ON A.BF_ORIGIN=B.BF_ORIGIN AND A.&기준.=B.&기준.
HAVING A.PRE_QTY<=B.MAX_PREQTY  AND A.REAL_QTY<=B.MAX_PREQTY

ORDER BY A.BF_ORIGIN ,A.CLASS_NM, A.&기준. ,A.RANK 
;
QUIT; 


/*-------------------------------------------------매출고려& 과거 판매율 고려*/
/*예측후 재고테이블 */


PROC SQL; 
CREATE TABLE  BEFORE_STK&LINE. AS
SELECT BF_ORIGIN,GOODS_CD
,SUM(BUY_QTY) AS BUY_QTY
,SUM(STK_QTY) AS STK_QTY
,SUM(SAL_QTY) AS SAL_QTY
FROM  STK&LINE._BEFORERAW
GROUP BY 1,2
;
QUIT; 


PROC SQL; 
CREATE TABLE DEL_GOODS_&BIZ._TEST AS
SELECT A.*,B.GOODS_REGION_CD AS BIZPL_REGION_CD, 
D.PRC,D.COST, (D.PRC-D.COST)*A.PRE_QTY AS PRE_PROFIT  
,(C.SAL_QTY/C.BUY_QTY) AS 과거판매율 
FROM TEST_02_&BIZ. AS A
LEFT JOIN 공결점포02 AS B
ON A.BF_ORIGIN=B.ORIGIN_BIZPL_CD
LEFT JOIN PRC_TEST01 AS D
ON A.GOODS_CD=D.GOODS_CD AND B.GOODS_REGION_CD=D.GOODS_REGION_CD
LEFT JOIN BEFORE_STK39 AS C
ON A.GOODS_CD=C.GOODS_CD AND A.BF_ORIGIN=C.BF_ORIGIN 
WHERE REAL_QTY ^=. 
HAVING 과거판매율 <1.08
ORDER BY BF_ORIGIN, 세분류명,REAL_QTY,PRE_PROFIT
;
QUIT; 

PROC MEANS DATA=DEL_GOODS_&BIZ._TEST P25 P50 P75 MEAN MAX ;

VAR 과거판매율 ; /*3분위수  1.08정도*/ 
QUIT; 
DATA DEL_GOODS_&BIZ._TEST ;
SET DEL_GOODS_&BIZ._TEST ;
BY BF_ORIGIN 세분류명 ;
RANK+1-RANK*FIRST.세분류명  ;
RUN;



PROC SQL;
CREATE TABLE TEST_REC_&BIZ._TEST AS
SELECT A.*
			,B.GOODS_CD AS GOODS_CD_YN
			,B.GOODs_NM AS GOODS_NM_YN
			,B.PRE_QTY AS PRE_YN
			,B.REAL_QTY AS REAL_YN
			,B.PRE_PROFIT AS PROFIT_YN
			,CASE WHEN B.PRE_QTY-A.PRE_QTY >0.07 THEN 0 ELSE 1 END AS DEL1
			,CASE WHEN B.PRE_QTY-A.REAL_QTY >0.07 THEN 0 ELSE 1 END AS DEL2
			,CASE WHEN B.PRE_PROFIT-A.PRE_PROFIT >0 THEN  0 ELSE 1 END AS DEL3
FROM DEL_GOODS_&BIZ._TEST AS A
INNER JOIN  TEST_SCORE04_&BIZ. AS B 
ON A.BF_ORIGIN = B.BF_ORIGIN AND A.세분류명=B.세분류명 AND A.RANK=B.RANK
HAVING DEL1=0 AND DEL2=0 AND DEL3=0
/*14일동안 1개라도 더 팔리게!*/
ORDER BY A.BF_ORIGIN ,A.CLASS_NM, A.세분류명 ,A.RANK ;
;
QUIT;
